{% extends "layout.html" %} {% block title %} Holdings {% endblock %} {% block main %}
<h1>Holdings</h1>
{% if holdings is not none %}
<div class="table-container">
	<table style="display: none">
		<thead>
			<tr>
				<th>Company Name</th>
				<th>Symbol</th>
				<th>Shares</th>
				<th>Price</th>
				<th>Value</th>
				<th>Sell</th>
				<th>Buy</th>
			</tr>
		</thead>
		<tbody>
			{%for holding in holdings %}
			<tr class="holding">
				<td>{{holding.company_name}}</td>
				<td class="symbol" data-value="{{holding.symbol}}">{{holding.symbol}}</td>
				<td class="current-shares" data-value="{{holding.shares}}">{{holding.shares}}</td>
				<td class="price">
					<div class="spinner-border spinner-border-sm text-primary" role="status">
						<span class="visually-hidden">Loading...</span>
					</div>
				</td>
				<td class="value">
					<div class="spinner-border spinner-border-sm text-primary" role="status">
						<span class="visually-hidden">Loading...</span>
					</div>
				</td>
				<td>
					<input
						type="number"
						min="1"
						max="{{ holding.shares }}"
						class="sell-input"
						form="sell-form"
						disabled
						step="1"
					/>
				</td>
				<td>
					<input type="number" class="buy-input" form="buy-form" disabled step="1" />
				</td>
			</tr>
			{% endfor %}
		</tbody>
		<tfoot>
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td class="footer">Total</td>
				<td class="total">
					<div class="spinner-border spinner-border-sm text-primary" role="status">
						<span class="visually-hidden">Loading...</span>
					</div>
				</td>
				<td class="sell-total"></td>
				<td class="buy-total"></td>
			</tr>
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td class="footer">Balance</td>
				<td class="balance">
					<div class="spinner-border spinner-border-sm text-primary" role="status">
						<span class="visually-hidden">Loading...</span>
					</div>
				</td>
				<td>
					<form class="sell-form">
						<button type="submit" class="btn btn-primary sell-button" disabled>Sell</button>

						<div class="spinner-border text-primary sell-spinner" role="status">
							<span class="visually-hidden">Loading...</span>
						</div>
					</form>
				</td>
				<td>
					<form class="buy-form">
						<button type="submit" class="btn btn-primary buy-button" disabled>Buy</button>

						<div class="spinner-border text-primary buy-spinner" role="status">
							<span class="visually-hidden">Loading...</span>
						</div>
					</form>
				</td>
			</tr>
		</tfoot>
	</table>
</div>
<span class="message"></span>
{% else %}
<span>Error loading holdings</span>
{% endif %} {% endblock %} {% block script%}
<script>
	document.addEventListener("DOMContentLoaded", async () => {
		const message = document.querySelector(".message");
		const interval = JSON.parse(localStorage.getItem("interval"));

		const balanceCell = document.querySelector(".balance");
		const totalCell = document.querySelector(".total");

		let balance = await fetchBalance();
		if (balance) {
			balanceCell.textContent = `$${balance.toFixed(2)}`;
		} else {
			balanceCell.textContent = `$--`;
			balanceCell.style.color = "red";
		}

		const buySpinner = document.querySelector(".buy-spinner");
		const buyButton = document.querySelector(".buy-button");

		const sellSpinner = document.querySelector(".sell-spinner");
		const sellButton = document.querySelector(".sell-button");

		const buyForm = document.querySelector(".buy-form");
		const sellForm = document.querySelector(".sell-form");

		const buyTotal = document.querySelector(".buy-total");
		const sellTotal = document.querySelector(".sell-total");

		const table = document.querySelector("table");

		let priceIntervalId;
		let transactionInProgress;

		const holdings = document.querySelectorAll(".holding");

		const calculateTotal = () => {
			let total = 0;
			holdings.forEach((holding) => {
				total += Number(holding.querySelector(".value").dataset.value);
			});
			return Number(total.toFixed(2));
		};

		const cachedHoldings = {};
		for (const holding of holdings) {
			const symbol = holding.querySelector(".symbol").dataset.value;
			cachedHoldings[symbol] = {
				priceCell: holding.querySelector(".price"),
				valueCell: holding.querySelector(".value"),
				sharesCell: holding.querySelector(".current-shares"),
				buyInput: holding.querySelector(".buy-input"),
				sellInput: holding.querySelector(".sell-input"),
			};
		}

		const allHoldings = Object.values(cachedHoldings);

		const url = `/prices?symbols=${Object.keys(cachedHoldings).join(",")}`;

		const fetchPrices = async () => {
			const res = await fetch(url);
			const data = await res.json().catch((error) => console.error(error));
			if (!res.ok) {
				throw new Error(data && data.error ? data.error : `Error ${res.status}: ${res.statusText}`);
			}
			return data;
		};

		const updatePrices = async (isFirstFetch = false) => {
			const DOMupdates = [];

			try {
				let updated = 0;
				let available = 0;
				const shares = await fetchPrices();

				const cachedShares = {};
				for (const share of shares) cachedShares[share.symbol] = share.price;

				for (const [symbol, mappedHolding] of Object.entries(cachedHoldings)) {
					const price = Number(cachedShares[symbol]);
					const { sharesCell, priceCell, valueCell, buyInput, sellInput } = mappedHolding;
					if (typeof price === "number" && !isNaN(price) && price > 0) {
						const shares = Number(sharesCell.dataset.value);
						const value = price * shares;
						priceCell.dataset.value = price;
						valueCell.dataset.value = value;

						let buyTotal = 0;
						for (const mH of allHoldings) {
							buyTotal += Number(mH.buyInput.value || 0) * Number(mH.priceCell.dataset.value || 0);
						}

						const remaining = balance - buyTotal + price * (Number(buyInput.value) || 0);
						const availableShares = Math.floor(remaining / price);
						const availableSharesMax = Math.floor(balance / price);
						if (availableSharesMax > 0) available++;

						DOMupdates.push(() => {
							priceCell.style.color = "";
							priceCell.textContent = `$${price.toFixed(2)}`;

							valueCell.style.color = "";
							valueCell.textContent = `$${value.toFixed(2)}`;

							if (isFirstFetch) sellInput.disabled = false;

							buyInput.max = availableShares;

							if (!transactionInProgress) buyInput.disabled = availableSharesMax > 0 ? false : true;
							buyInput.min = availableShares > 0 ? 1 : 0;
						});

						updated++;
					} else {
						console.warn(`Invalid price received for holding: ${symbol}`);
						DOMupdates.push(() => {
							if (isFirstFetch) {
								priceCell.textContent = `$--`;
								valueCell.textContent = `$--`;
							}
							priceCell.style.color = "red";
							valueCell.style.color = "red";
							sellInput.disabled = true;
							buyInput.disabled = true;
						});
					}
				}
				const total = calculateTotal();
				DOMupdates.push(() => {
					totalCell.style.color = updated === holdings.length ? "" : "red";
					totalCell.textContent = isNaN(total) ? `$--` : `$${total.toFixed(2)}`;
					if (isFirstFetch) {
						sellButton.disabled = false;
						if (balance && available > 0) buyButton.disabled = false;
					} else {
						buyButton.disabled = available === 0;
					}
				});
			} catch (error) {
				console.error(error);
				DOMupdates.push(() => {
					totalCell.style.color = "red";
					buyButton.disabled = sellButton.disabled = true;
					for (const mappedHolding of allHoldings) {
						const { sharesCell, priceCell, valueCell, buyInput, sellInput } = mappedHolding;
						priceCell.style.color = valueCell.style.color = "red";
						buyInput.disabled = true;
						sellInput.disabled = true;
						if (isFirstFetch) {
							priceCell.textContent = valueCell.textContent = totalCell.textContent = `$--`;
						}
					}
				});
			} finally {
				requestAnimationFrame(() => {
					for (const update of DOMupdates) {
						update();
					}
				});
			}
		};

		if (Object.keys(cachedHoldings).length) {
			table.style.display = "";
			updatePrices(true).then(() => {
				sellFormListener();
				buyFormListener();
				if (priceIntervalId) clearInterval(priceIntervalId);
				priceIntervalId = setInterval(() => {
					updatePrices()
						.then(() => {
							if (!transactionInProgress) {
								[firstHolding] = allHoldings;
								if (buyTotal.textContent) firstHolding.buyInput.dispatchEvent(new Event("input"));
								if (sellTotal.textContent) firstHolding.sellInput.dispatchEvent(new Event("input"));
							}
						})
						.catch((error) => console.error(error));
				}, interval);
			});
		} else {
			message.innerHTML =
				'No holdings to display - go to the <a href="/search">Search</a> page to start trading.';
		}

		const buyFormListener = () => {
			buyForm.addEventListener("submit", async (e) => {
				e.preventDefault();
				if (transactionInProgress) return;
				transactionInProgress = true;
				message.textContent = "";
				const purchases = {};
				let purchaseTotal = 0;
				let invalidInput = false;

				for (const [symbol, mappedHolding] of Object.entries(cachedHoldings)) {
					if (invalidInput) break;

					const { sharesCell, priceCell, buyInput, sellInput } = mappedHolding;

					const price = Number(priceCell.dataset.value);
					const quantity = Number(buyInput.value);

					purchaseTotal += quantity * price;
					if (
						quantity < 0 ||
						!Number.isInteger(quantity) ||
						(!buyInput.checkValidity() && buyInput.value !== "0")
					) {
						invalidInput = true;
						break;
					}

					if (quantity > 0) {
						purchases[symbol] = quantity;
					}
				}
				if (purchaseTotal > balance) {
					message.textContent = "Could not complete trade - insufficient funds.";
					transactionInProgress = false;
					return;
				}
				if (invalidInput) {
					message.textContent = "Invalid input - must be positive integers.";
					transactionInProgress = false;
					return;
				}
				if (!Object.keys(purchases).length) {
					message.textContent = "No shares selected to trade.";
					transactionInProgress = false;
					return;
				}

				const DOMupdates = [];

				try {
					buySpinner.style.setProperty("display", "flex", "important");
					buyButton.style.display = "none";
					document.querySelectorAll("input, button").forEach((el) => (el.disabled = true));
					const res = await fetch("/buy", {
						method: "POST",
						headers: {
							"Content-Type": "application/json",
						},
						body: JSON.stringify(purchases),
					});
					const data = await res.json();
					if (!res.ok) throw new Error(data?.error || `Error ${res.status}: ${res.statusText}`);
					if (!data || !data.updated_balance) throw new Error("Missing data");

					const { successful, failed, updated_balance: updatedBalance } = data;

					setBalance(updatedBalance);
					balance = updatedBalance;

					for (const trade of successful) {
						const symbol = trade.symbol;
						const mappedHolding = cachedHoldings[symbol];
						if (!mappedHolding) continue;

						const { sharesCell, priceCell, valueCell, buyInput, sellInput } = mappedHolding;

						const price = Number(priceCell.dataset.value);
						const currentShares = Number(sharesCell.dataset.value);
						const shares = trade.shares;

						if (shares) {
							const updatedShares = currentShares + shares;
							const updatedValue = price * updatedShares;

							DOMupdates.push(() => {
								sharesCell.dataset.value = updatedShares;
								valueCell.dataset.value = updatedValue;
								sellInput.max = updatedShares;
								sharesCell.textContent = updatedShares;
								valueCell.textContent = `$${updatedValue.toFixed(2)}`;
							});
						}
					}
					let available = 0;
					for (const mappedHolding of allHoldings) {
						const { buyInput, sellInput, priceCell } = mappedHolding;
						const price = Number(priceCell.dataset.value);
						const availableShares = price > 0 ? Math.floor(updatedBalance / price) : 0;
						if (availableShares > 0) available++;
						DOMupdates.push(() => {
							buyInput.max = availableShares;
							buyInput.value = sellInput.value = "";
						});
					}
					const total = calculateTotal();

					DOMupdates.push(() => {
						message.textContent = "Purchase Successful!";
						balanceCell.style.color = "";
						balanceCell.textContent = `$${updatedBalance.toFixed(2)}`;
						buyTotal.textContent = sellTotal.textContent = "";
						totalCell.dataset.value = total;
						totalCell.textContent = `$${total.toFixed(2)}`;
						buyButton.disabled = available === 0;
					});
				} catch (error) {
					console.error(error.message);
					buyButton.disabled = false;
					message.textContent = error.message == "Insufficient funds" ? error.message : "Unexpected error";
				} finally {
					DOMupdates.push(() => {
						buySpinner.style.setProperty("display", "none", "important");
						buyButton.style.display = "";
						sellButton.disabled = false;
						for (const mappedHolding of allHoldings) {
							const { buyInput, sellInput } = mappedHolding;

							const buyMax = Number(buyInput.max) > 0;
							buyInput.disabled = !buyMax;
							buyInput.min = buyMax ? 1 : 0;

							const sellMax = Number(sellInput.max) > 0;
							sellInput.disabled = !sellMax;
							sellInput.min = sellMax ? 1 : 0;
						}
					});
					requestAnimationFrame(() => {
						for (const update of DOMupdates) {
							update();
						}
					});
					transactionInProgress = false;
				}
			});
		};

		const sellFormListener = () => {
			sellForm.addEventListener("submit", async (e) => {
				e.preventDefault();
				if (transactionInProgress) return;
				transactionInProgress = true;
				const sales = {};
				message.textContent = "";
				let invalidQuantity = false;
				let invalidInput = false;

				for (const [symbol, mappedHolding] of Object.entries(cachedHoldings)) {
					if (invalidQuantity || invalidInput) break;

					const { sharesCell, priceCell, valueCell, buyInput, sellInput } = mappedHolding;

					const price = Number(priceCell.dataset.value);
					const currentShares = Number(sharesCell.dataset.value);
					const quantity = Number(sellInput.value);

					if (quantity > currentShares) {
						invalidQuantity = true;
						break;
					}
					if (
						quantity < 0 ||
						!Number.isInteger(quantity) ||
						(!sellInput.checkValidity() && sellInput.value !== "0")
					) {
						invalidInput = true;
						break;
					}

					if (quantity > 0) {
						sales[symbol] = quantity;
					}
				}

				if (invalidQuantity) {
					message.textContent = "Could not complete trade - insufficient shares.";
					transactionInProgress = false;
					return;
				}
				if (invalidInput) {
					message.textContent = "Invalid input - must be positive integers.";
					transactionInProgress = false;
					return;
				}
				if (!Object.keys(sales).length) {
					message.textContent = "No shares selected to trade.";
					transactionInProgress = false;
					return;
				}

				const DOMupdates = [];

				try {
					sellSpinner.style.setProperty("display", "flex", "important");
					sellButton.style.display = "none";
					document.querySelectorAll("input, button").forEach((el) => (el.disabled = true));
					const res = await fetch("/sell", {
						method: "POST",
						headers: {
							"Content-Type": "application/json",
						},
						body: JSON.stringify(sales),
					});
					const data = await res.json();

					if (!res.ok) throw new Error(data?.error || `Error ${res.status}: ${res.statusText}`);
					if (!data || !data.updated_balance) throw new Error("Missing data");

					const { successful, failed, updated_balance: updatedBalance } = data;

					setBalance(updatedBalance);
					balance = updatedBalance;

					for (const trade of successful) {
						const symbol = trade.symbol;
						const mappedHolding = cachedHoldings[symbol];
						if (!mappedHolding) continue;

						const { sharesCell, priceCell, valueCell, buyInput, sellInput } = mappedHolding;

						const price = Number(priceCell.dataset.value);
						const currentShares = Number(sharesCell.dataset.value);

						const shares = trade.shares;

						const updatedShares = currentShares - shares;
						const updatedValue = price * updatedShares;
						DOMupdates.push(() => {
							valueCell.dataset.value = updatedValue;
							sharesCell.dataset.value = updatedShares;
							sharesCell.textContent = updatedShares;
							sellInput.max = updatedShares;
							valueCell.textContent = `$${updatedValue.toFixed(2)}`;
						});
					}
					let available = 0;
					for (const mappedHolding of allHoldings) {
						const { priceCell, buyInput, sellInput } = mappedHolding;
						const price = Number(priceCell.dataset.value);
						const availableShares = price > 0 ? Math.floor(updatedBalance / price) : 0;
						if (availableShares > 0) available++;

						DOMupdates.push(() => {
							buyInput.max = availableShares;
							sellInput.value = buyInput.value = "";
						});
					}

					const total = calculateTotal();

					DOMupdates.push(() => {
						message.textContent = "Sale Successful!";
						balanceCell.style.color = "";
						balanceCell.textContent = `$${updatedBalance.toFixed(2)}`;
						buyTotal.textContent = sellTotal.textContent = "";
						totalCell.dataset.value = total;
						totalCell.textContent = `$${total.toFixed(2)}`;
						buyButton.disabled = available === 0;
					});
				} catch (error) {
					buyButton.disabled = false;
					console.error(error.message);
					message.textContent = "Unexpected error";
				} finally {
					DOMupdates.push(() => {
						sellSpinner.style.setProperty("display", "none", "important");
						sellButton.style.display = "";
						sellButton.disabled = false;
						for (const mappedHolding of allHoldings) {
							const { buyInput, sellInput } = mappedHolding;

							const buyMax = Number(buyInput.max) > 0;
							buyInput.disabled = !buyMax;
							buyInput.min = buyMax ? 1 : 0;

							const sellMax = Number(sellInput.max) > 0;
							sellInput.disabled = !sellMax;
							sellInput.min = sellMax ? 1 : 0;
						}
					});
					requestAnimationFrame(() => {
						for (const update of DOMupdates) {
							update();
						}
					});
					transactionInProgress = false;
				}
			});
		};

		const tbody = document.querySelector("table tbody");

		tbody.addEventListener("input", (event) => {
			const target = event.target;
			if (!target.classList.contains("buy-input")) return;

			let buySum = 0;
			let countNaN = 0;

			allHoldings.forEach((holding) => {
				const { priceCell, buyInput } = holding;
				const price = Number(priceCell.dataset.value);
				const quantity = Number(buyInput.value) || 0;
				if (isNaN(buyInput.valueAsNumber)) countNaN += 1;
				buySum += price * quantity;
			});
			buyTotal.textContent = countNaN === allHoldings.length ? "" : `$${buySum.toFixed(2)}`;

			allHoldings.forEach((holding) => {
				const { priceCell, buyInput } = holding;
				const price = Number(priceCell.dataset.value);
				const quantity = Number(buyInput.value) || 0;

				const remaining = balance - buySum + price * quantity;
				const availableShares = price > 0 ? Math.max(0, Math.floor(remaining / price)) : 0;
				buyInput.max = availableShares;
				buyInput.min = availableShares > 0 ? 1 : 0;
			});
		});

		tbody.addEventListener("input", (event) => {
			const target = event.target;
			if (!target.classList.contains("sell-input")) return;

			let sellSum = 0;
			let countNaN = 0;
			allHoldings.forEach((holding) => {
				const { priceCell, sellInput } = holding;
				const price = Number(priceCell.dataset.value);
				const quantity = Number(sellInput.value) || 0;
				if (isNaN(sellInput.valueAsNumber)) countNaN += 1;
				sellSum += price * quantity;
			});
			sellTotal.textContent = countNaN === sellInputs.length ? "" : `$${sellSum.toFixed(2)}`;
		});
	});
</script>

{% endblock %}
