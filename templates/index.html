{% extends "layout.html" %} {% block title %} Holdings {% endblock %} {% block main %}
<h1>Holdings</h1>
{% if holdings is not none %}
<div class="table-container">
	<table style="display: none">
		<thead>
			<tr>
				<th>Company Name</th>
				<th>Symbol</th>
				<th>Shares</th>
				<th>Price</th>
				<th>Value</th>
				<th>Sell</th>
				<th>Buy</th>
			</tr>
		</thead>
		<tbody>
			{%for holding in holdings %}
			<tr class="holding">
				<td>{{holding.company_name}}</td>
				<td class="symbol" data-value="{{holding.symbol}}">{{holding.symbol}}</td>
				<td class="current-shares" data-value="{{holding.shares}}">{{holding.shares}}</td>
				<td class="price">
					<div class="spinner-border spinner-border-sm text-primary" role="status">
						<span class="visually-hidden">Loading...</span>
					</div>
				</td>
				<td class="value">
					<div class="spinner-border spinner-border-sm text-primary" role="status">
						<span class="visually-hidden">Loading...</span>
					</div>
				</td>
				<td>
					<input
						type="number"
						min="1"
						max="{{ holding.shares }}"
						class="sell-input"
						form="sell-form"
						disabled
						step="1"
					/>
				</td>
				<td>
					<input type="number" class="buy-input" form="buy-form" disabled step="1" />
				</td>
			</tr>
			{% endfor %}
		</tbody>
		<tfoot>
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td class="footer">Total</td>
				<td class="total">
					<div class="spinner-border spinner-border-sm text-primary" role="status">
						<span class="visually-hidden">Loading...</span>
					</div>
				</td>
				<td class="sell-total"></td>
				<td class="buy-total"></td>
			</tr>
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td class="footer">Balance</td>
				<td class="balance">
					<div class="spinner-border spinner-border-sm text-primary" role="status">
						<span class="visually-hidden">Loading...</span>
					</div>
				</td>
				<td>
					<form class="sell-form">
						<button type="submit" class="btn btn-primary sell-button" disabled>Sell</button>

						<div class="spinner-border text-primary sell-spinner" role="status">
							<span class="visually-hidden">Loading...</span>
						</div>
					</form>
				</td>
				<td>
					<form class="buy-form">
						<button type="submit" class="btn btn-primary buy-button" disabled>Buy</button>

						<div class="spinner-border text-primary buy-spinner" role="status">
							<span class="visually-hidden">Loading...</span>
						</div>
					</form>
				</td>
			</tr>
		</tfoot>
	</table>
</div>
<span class="message"></span>
{% else %}
<span>Error loading holdings</span>
{% endif %} {% endblock %} {% block script%}
<script>
	document.addEventListener("DOMContentLoaded", async () => {
		const message = document.querySelector(".message");
		const interval = JSON.parse(localStorage.getItem("interval"));

		const balanceCell = document.querySelector(".balance");
		const totalCell = document.querySelector(".total");

		let balance = await fetchBalance();
		if (balance) {
			balanceCell.textContent = `$${balance.toFixed(2)}`;
		} else {
			balanceCell.textContent = `$--`;
			balanceCell.style.color = "red";
		}

		const buySpinner = document.querySelector(".buy-spinner");
		const buyButton = document.querySelector(".buy-button");

		const sellSpinner = document.querySelector(".sell-spinner");
		const sellButton = document.querySelector(".sell-button");

		const buyForm = document.querySelector(".buy-form");
		const sellForm = document.querySelector(".sell-form");

		const buyTotal = document.querySelector(".buy-total");
		const sellTotal = document.querySelector(".sell-total");

		const buyInputs = document.querySelectorAll(".buy-input");
		const sellInputs = document.querySelectorAll(".sell-input");

		const table = document.querySelector("table");

		let priceIntervalId;
		let transactionInProgress;

		const holdings = document.querySelectorAll(".holding");

		const calculateTotal = () => {
			let total = 0;
			holdings.forEach((holding) => {
				total += Number(holding.querySelector(".value").dataset.value);
			});
			return Number(total.toFixed(2));
		};

		const cachedHoldings = {};
		for (const holding of holdings) {
			const symbol = holding.querySelector(".symbol").dataset.value;

			cachedHoldings[symbol] = {
				priceCell: holding.querySelector(".price"),
				valueCell: holding.querySelector(".value"),
				sharesCell: holding.querySelector(".current-shares"),
				buyInput: holding.querySelector(".buy-input"),
				sellInput: holding.querySelector(".sell-input"),
			};
		}

		const url = `/prices?symbols=${Object.keys(cachedHoldings).join(",")}`;

		const fetchPrices = async () => {
			const res = await fetch(url);
			const data = await res.json().catch((error) => console.error(error));
			if (!res.ok) {
				throw new Error(data && data.error ? data.error : `Error ${res.status}: ${res.statusText}`);
			}
			return data;
		};

		const updatePrices = async (isFirstFetch = false) => {
			const DOMupdates = [];

			try {
				let updated = 0;
				const shares = await fetchPrices();

				const cachedShares = {};
				for (const share of shares) cachedShares[share.symbol] = share.price;

				for (const [symbol, mappedHolding] of Object.entries(cachedHoldings)) {
					const price = Number(cachedShares[symbol]);
					if (typeof price === "number" && !isNaN(price) && price > 0) {
						const shares = Number(mappedHolding.sharesCell.dataset.value);
						const value = price * shares;
						mappedHolding.priceCell.dataset.value = price;
						mappedHolding.valueCell.dataset.value = value;

						let buyTotal = 0;
						for (const mH of Object.values(cachedHoldings)) {
							buyTotal += Number(mH.buyInput.value || 0) * Number(mH.priceCell.dataset.value || 0);
						}

						const remaining = balance - buyTotal + price * (Number(mappedHolding.buyInput.value) || 0);
						const availableShares = Math.floor(remaining / price);
						const availableSharesMax = Math.floor(balance / price);

						DOMupdates.push(() => {
							mappedHolding.priceCell.style.color = "";
							mappedHolding.priceCell.textContent = `$${price.toFixed(2)}`;

							mappedHolding.valueCell.style.color = "";
							mappedHolding.valueCell.textContent = `$${value.toFixed(2)}`;

							if (isFirstFetch) mappedHolding.sellInput.disabled = false;

							mappedHolding.buyInput.max = availableShares;

							if (!transactionInProgress)
								mappedHolding.buyInput.disabled = availableSharesMax > 0 ? false : true;
							mappedHolding.buyInput.min = availableShares > 0 ? 1 : 0;
						});

						updated++;
					} else {
						console.warn(`Invalid price received for holding: ${symbol}`);
						DOMupdates.push(() => {
							if (isFirstFetch) {
								mappedHolding.priceCell.textContent = `$--`;
								mappedHolding.valueCell.textContent = `$--`;
							}
							mappedHolding.priceCell.style.color = "red";
							mappedHolding.valueCell.style.color = "red";
							mappedHolding.sellInput.disabled = true;
							mappedHolding.buyInput.disabled = true;
						});
					}
				}
				const total = calculateTotal();
				DOMupdates.push(() => {
					totalCell.style.color = updated === holdings.length ? "" : "red";
					totalCell.textContent = isNaN(total) ? `$--` : `$${total.toFixed(2)}`;
					if (isFirstFetch) {
						sellButton.disabled = false;
						if (balance) buyButton.disabled = false;
					}
				});
			} catch (error) {
				console.error(error);
				DOMupdates.push(() => {
					totalCell.style.color = "red";
					buyButton.disabled = sellButton.disabled = true;
					for (const mappedHolding of Object.values(cachedHoldings)) {
						mappedHolding.priceCell.style.color = mappedHolding.valueCell.style.color = "red";
						mappedHolding.buyInput.disabled = true;
						mappedHolding.sellInput.disabled = true;
						if (isFirstFetch) {
							mappedHolding.priceCell.textContent =
								mappedHolding.valueCell.textContent =
								totalCell.textContent =
									`$--`;
						}
					}
				});
			} finally {
				requestAnimationFrame(() => {
					for (const update of DOMupdates) {
						update();
					}
				});
			}
		};

		if (Object.keys(cachedHoldings).length) {
			table.style.display = "";
			updatePrices(true).then(() => {
				sellFormListener();
				buyFormListener();
				if (priceIntervalId) clearInterval(priceIntervalId);
				priceIntervalId = setInterval(() => {
					updatePrices()
						.then(() => {
							if (!transactionInProgress) {
								if (buyTotal.textContent) buyInputs[0].dispatchEvent(new InputEvent("input"));
								if (sellTotal.textContent) sellInputs[0].dispatchEvent(new InputEvent("input"));
							}
						})
						.catch((error) => console.error(error));
				}, interval);
			});
		} else {
			message.innerHTML =
				'No holdings to display - go to the <a href="/search">Search</a> page to start trading.';
		}

		const buyFormListener = () => {
			buyForm.addEventListener("submit", async (e) => {
				e.preventDefault();
				if (transactionInProgress) return;
				transactionInProgress = true;
				message.textContent = "";
				const purchases = {};
				let purchaseTotal = 0;
				let invalidInput = false;

				for (const [symbol, mappedHolding] of Object.entries(cachedHoldings)) {
					if (invalidInput) break;

					const price = Number(mappedHolding.priceCell.dataset.value);
					const quantity = Number(mappedHolding.buyInput.value);

					purchaseTotal += quantity * price;
					if (quantity < 0 || !Number.isInteger(quantity) || !mappedHolding.buyInput.checkValidity()) {
						invalidInput = true;
						break;
					}

					if (quantity > 0) {
						purchases[symbol] = quantity;
					}
				}
				if (purchaseTotal > balance) {
					message.textContent = "Could not complete trade - insufficient funds.";
					transactionInProgress = false;
					return;
				}
				if (invalidInput) {
					message.textContent = "Invalid input - must be positive integers.";
					transactionInProgress = false;
					return;
				}
				if (!Object.keys(purchases).length) {
					message.textContent = "No shares selected to trade.";
					transactionInProgress = false;
					return;
				}

				const DOMupdates = [];

				try {
					buySpinner.style.setProperty("display", "flex", "important");
					buyButton.style.display = "none";
					document.querySelectorAll("input, button").forEach((el) => (el.disabled = true));
					const res = await fetch("/buy", {
						method: "POST",
						headers: {
							"Content-Type": "application/json",
						},
						body: JSON.stringify(purchases),
					});
					const data = await res.json();
					if (!res.ok) throw new Error(data?.error || `Error ${res.status}: ${res.statusText}`);
					if (!data || !data.updated_balance) throw new Error("Missing data");

					const { successful, failed, updated_balance: updatedBalance } = data;

					setBalance(updatedBalance);
					balance = updatedBalance;

					for (const trade of successful) {
						const symbol = trade.symbol;
						const mappedHolding = cachedHoldings[symbol];
						if (!mappedHolding) continue;
						const price = Number(mappedHolding.priceCell.dataset.value);
						const currentShares = Number(mappedHolding.sharesCell.dataset.value);
						const shares = trade.shares;
						const availableShares = price > 0 ? Math.floor(updatedBalance / price) : 0;

						DOMupdates.push(() => {
							mappedHolding.buyInput.max = availableShares;
							mappedHolding.buyInput.value = mappedHolding.sellInput.value = "";
						});

						if (shares) {
							const updatedShares = currentShares + shares;
							const updatedValue = price * updatedShares;

							DOMupdates.push(() => {
								mappedHolding.sharesCell.dataset.value = updatedShares;
								mappedHolding.valueCell.dataset.value = updatedValue;
								mappedHolding.sellInput.max = updatedShares;
								mappedHolding.sharesCell.textContent = updatedShares;
								mappedHolding.valueCell.textContent = `$${updatedValue.toFixed(2)}`;
							});
						}
					}
					const total = calculateTotal();

					DOMupdates.push(() => {
						message.textContent = "Purchase Successful!";
						balanceCell.style.color = "";
						balanceCell.textContent = `$${updatedBalance.toFixed(2)}`;
						buyTotal.textContent = sellTotal.textContent = "";
						totalCell.dataset.value = total;
						totalCell.textContent = `$${total.toFixed(2)}`;
					});
				} catch (error) {
					console.error(error.message);
					message.textContent = error.message == "Insufficient funds" ? error.message : "Unexpected error";
				} finally {
					DOMupdates.push(() => {
						buySpinner.style.setProperty("display", "none", "important");
						buyButton.style.display = "";
						sellButton.disabled = buyButton.disabled = false;
						for (const mappedHolding of Object.values(cachedHoldings)) {
							if (Number(mappedHolding.buyInput.max) > 0) {
								mappedHolding.buyInput.disabled = false;
								mappedHolding.buyInput.min = 1;
							} else {
								mappedHolding.buyInput.disabled = true;
								mappedHolding.buyInput.min = 0;
							}
							if (Number(mappedHolding.sellInput.max) > 0) {
								mappedHolding.sellInput.disabled = false;
								mappedHolding.sellInput.min = 1;
							} else {
								mappedHolding.sellInput.disabled = true;
								mappedHolding.sellInput.min = 0;
							}
						}
					});
					requestAnimationFrame(() => {
						for (const update of DOMupdates) {
							update();
						}
					});
					transactionInProgress = false;
				}
			});
		};

		const sellFormListener = () => {
			sellForm.addEventListener("submit", async (e) => {
				e.preventDefault();
				if (transactionInProgress) return;
				transactionInProgress = true;
				const sales = {};
				const holdings = document.querySelectorAll(".holding");
				message.textContent = "";
				let invalidQuantity = false;
				let invalidInput = false;

				for (const [symbol, mappedHolding] of Object.entries(cachedHoldings)) {
					if (invalidQuantity || invalidInput) break;

					const price = Number(mappedHolding.priceCell.dataset.value);
					const currentShares = Number(mappedHolding.sharesCell.dataset.value);
					const quantity = Number(mappedHolding.sellInput.value);

					if (quantity > currentShares) {
						invalidQuantity = true;
						break;
					}
					if (quantity < 0 || !Number.isInteger(quantity) || !mappedHolding.sellInput.checkValidity()) {
						invalidInput = true;
						break;
					}

					if (quantity > 0) {
						sales[symbol] = quantity;
					}
				}

				if (invalidQuantity) {
					message.textContent = "Could not complete trade - insufficient shares.";
					transactionInProgress = false;
					return;
				}
				if (invalidInput) {
					message.textContent = "Invalid input - must be positive integers.";
					transactionInProgress = false;
					return;
				}
				if (!Object.keys(sales).length) {
					message.textContent = "No shares selected to trade.";
					transactionInProgress = false;
					return;
				}

				const DOMupdates = [];

				try {
					sellSpinner.style.setProperty("display", "flex", "important");
					sellButton.style.display = "none";
					document.querySelectorAll("input, button").forEach((el) => (el.disabled = true));
					const res = await fetch("/sell", {
						method: "POST",
						headers: {
							"Content-Type": "application/json",
						},
						body: JSON.stringify(sales),
					});
					const data = await res.json();

					if (!res.ok) throw new Error(data?.error || `Error ${res.status}: ${res.statusText}`);
					if (!data || !data.updated_balance) throw new Error("Missing data");

					const { successful, failed, updated_balance: updatedBalance } = data;

					setBalance(updatedBalance);
					balance = updatedBalance;

					for (const trade of successful) {
						const symbol = trade.symbol;
						const mappedHolding = cachedHoldings[symbol];
						if (!mappedHolding) continue;
						const price = Number(mappedHolding.priceCell.dataset.value);
						const currentShares = Number(mappedHolding.sharesCell.dataset.value);

						const shares = trade.shares;

						const availableShares = price > 0 ? Math.floor(updatedBalance / price) : 0;

						DOMupdates.push(() => {
							mappedHolding.buyInput.max = availableShares;
							mappedHolding.sellInput.value = mappedHolding.buyInput.value = "";
						});

						const updatedShares = currentShares - shares;
						const updatedValue = price * updatedShares;
						DOMupdates.push(() => {
							mappedHolding.valueCell.dataset.value = updatedValue;
							mappedHolding.sharesCell.dataset.value = updatedShares;
							mappedHolding.sharesCell.textContent = updatedShares;
							mappedHolding.sellInput.max = updatedShares;
							mappedHolding.valueCell.textContent = `$${updatedValue.toFixed(2)}`;
						});
					}
					const total = calculateTotal();

					DOMupdates.push(() => {
						message.textContent = "Sale Successful!";
						balanceCell.style.color = "";
						balanceCell.textContent = `$${updatedBalance.toFixed(2)}`;
						buyTotal.textContent = sellTotal.textContent = "";
						totalCell.dataset.value = total;
						totalCell.textContent = `$${total.toFixed(2)}`;
					});
				} catch (error) {
					console.error(error.message);
					message.textContent = "Unexpected error";
				} finally {
					DOMupdates.push(() => {
						sellSpinner.style.setProperty("display", "none", "important");
						sellButton.style.display = "";
						buyButton.disabled = sellButton.disabled = false;
						for (const mappedHolding of Object.values(cachedHoldings)) {
							if (Number(mappedHolding.buyInput.max) > 0) {
								mappedHolding.buyInput.disabled = false;
								mappedHolding.buyInput.min = 1;
							} else {
								mappedHolding.buyInput.disabled = true;
								mappedHolding.buyInput.min = 0;
							}
							if (Number(mappedHolding.sellInput.max) > 0) {
								mappedHolding.sellInput.disabled = false;
								mappedHolding.sellInput.min = 1;
							} else {
								mappedHolding.sellInput.disabled = true;
								mappedHolding.sellInput.min = 0;
							}
						}
					});
					requestAnimationFrame(() => {
						for (const update of DOMupdates) {
							update();
						}
					});
					transactionInProgress = false;
				}
			});
		};

		buyInputs.forEach((input) => {
			input.addEventListener("input", (event) => {
				let buySum = 0;
				let countNaN = 0;
				buyInputs.forEach((input) => {
					const price = Number(input.closest("tr").querySelector(".price").dataset.value);
					const value = Number(input.value) || 0;
					if (isNaN(input.valueAsNumber)) countNaN += 1;
					buySum += price * value;
				});
				buyTotal.textContent = countNaN === buyInputs.length ? "" : `$${buySum.toFixed(2)}`;

				buyInputs.forEach((input) => {
					const price = Number(input.closest("tr").querySelector(".price").dataset.value);
					const value = Number(input.value) || 0;

					const remaining = balance - buySum + price * value;
					const availableShares = price > 0 ? Math.max(0, Math.floor(remaining / price)) : 0;
					input.max = availableShares;
					input.min = availableShares > 0 ? 1 : 0;
				});
			});
		});

		sellInputs.forEach((input) => {
			input.addEventListener("input", (event) => {
				let sellSum = 0;
				let countNaN = 0;
				sellInputs.forEach((input) => {
					const price = Number(input.closest("tr").querySelector(".price").dataset.value);
					const value = Number(input.value) || 0;
					if (isNaN(input.valueAsNumber)) countNaN += 1;
					sellSum += price * value;
				});
				sellTotal.textContent = countNaN === sellInputs.length ? "" : `$${sellSum.toFixed(2)}`;
			});
		});
	});
</script>

{% endblock %}
