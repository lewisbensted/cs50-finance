{% extends "layout.html" %} {% block title %} Holdings {% endblock %} {% block main %}
<h1>Holdings</h1>
<br />
{% if holdings is not none %}
<table style="display: none">
	<thead>
		<tr>
			<th>Company Name</th>
			<th>Symbol</th>
			<th>Shares</th>
			<th>Price</th>
			<th>Value</th>
			<th>Sell</th>
			<th>Buy</th>
		</tr>
	</thead>
	<tbody>
		{%for holding in holdings %}
		<tr class="holding">
			<td>{{holding.company_name}}</td>
			<td class="symbol" data-value="{{holding.symbol}}">{{holding.symbol}}</td>
			<td class="current-shares" data-value="{{holding.shares}}">{{holding.shares}}</td>
			<td class="price">
				<div class="spinner-border spinner-border-sm text-primary" role="status">
					<span class="visually-hidden">Loading...</span>
				</div>
			</td>
			<td class="value">
				<div class="spinner-border spinner-border-sm text-primary" role="status">
					<span class="visually-hidden">Loading...</span>
				</div>
			</td>
			<td>
				<input
					type="number"
					min="1"
					max="{{ holding.shares }}"
					class="sell-input"
					form="sell-form"
					disabled
					step="1"
				/>
			</td>
			<td>
				<input type="number" class="buy-input" form="buy-form" disabled step="1" />
			</td>
		</tr>
		{% endfor %}
	</tbody>
	<tfoot>
		<tr>
			<td></td>
			<td></td>
			<td></td>
			<td class="footer">Total</td>
			<td id="total">
				<div class="spinner-border spinner-border-sm text-primary" role="status">
					<span class="visually-hidden">Loading...</span>
				</div>
			</td>
			<td class="sell-total"></td>
			<td class="buy-total"></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
			<td class="footer">Balance</td>
			<td id="balance">
				<div class="spinner-border spinner-border-sm text-primary" role="status">
					<span class="visually-hidden">Loading...</span>
				</div>
			</td>
			<td>
				<form class="sell-form">
					<button type="submit" class="btn btn-primary sell-button" disabled>Sell</button>

					<div class="spinner-border text-primary sell-spinner" role="status">
						<span class="visually-hidden">Loading...</span>
					</div>
				</form>
			</td>
			<td>
				<form class="buy-form">
					<button type="submit" class="btn btn-primary buy-button" disabled>Buy</button>

					<div class="spinner-border text-primary buy-spinner" role="status">
						<span class="visually-hidden">Loading...</span>
					</div>
				</form>
			</td>
		</tr>
	</tfoot>
</table>
<span id="message"></span>
{% else %}
<span>Error loading holdings</span>
{% endif %} {% endblock %} {% block script%}
<script>
	document.addEventListener("DOMContentLoaded", async () => {
		const message = document.getElementById("message");
		const interval = JSON.parse(localStorage.getItem("interval"));

		const balanceCell = document.getElementById("balance");
		const totalCell = document.getElementById("total");

		let balance = await fetchBalance();
		if (balance) {
			balanceCell.textContent = `$${balance.toFixed(2)}`;
		} else {
			balanceCell.textContent = `$--`;
			balanceCell.style.color = "red";
		}

		const buySpinner = document.querySelector(".buy-spinner");
		const buyButton = document.querySelector(".buy-button");

		const sellSpinner = document.querySelector(".sell-spinner");
		const sellButton = document.querySelector(".sell-button");

		const buyForm = document.querySelector(".buy-form");
		const sellForm = document.querySelector(".sell-form");

		const buyTotal = document.querySelector(".buy-total");
		const sellTotal = document.querySelector(".sell-total");

		const buyInputs = document.querySelectorAll(".buy-input");
		const sellInputs = document.querySelectorAll(".sell-input");

		const table = document.querySelector("table");

		const symbols = [];
		let priceIntervalId;
		let transactionInProgress;

		const holdings = document.querySelectorAll(".holding");
		holdings.forEach((el) => {
			const symbolCell = el.querySelector(".symbol");
			symbols.push(symbolCell.textContent);
		});

		const calculateTotal = () => {
			let total = 0;
			holdings.forEach((holding) => {
				total += Number(holding.querySelector(".value").dataset.value);
			});
			return Number(total.toFixed(2));
		};

		const url = `/prices?symbols=${symbols.join(",")}`;

		const fetchPrices = async () => {
			const res = await fetch(url);
			const data = await res.json().catch((error) => console.error(error));
			if (!res.ok) {
				throw new Error(data && data.error ? data.error : `Error ${res.status}: ${res.statusText}`);
			}
			if (data.length !== symbols.length) throw new Error("Missing data");

			return data;
		};

		const updatePrices = async (isFirstFetch = false) => {
			const DOMupdates = [];
			try {
				let updated = 0;
				const prices = await fetchPrices();

				for (const holding of holdings) {
					const priceCell = holding.querySelector(".price");
					const valueCell = holding.querySelector(".value");
					const sharesCell = holding.querySelector(".current-shares");
					const share = prices.find((el) => el.symbol == holding.querySelector(".symbol").textContent);

					const buyInput = holding.querySelector(".buy-input");
					const sellInput = holding.querySelector(".sell-input");

					const price = Number(share?.price);
					if (typeof price == "number" && !isNaN(price) && price > 0) {
						const shares = Number(sharesCell.dataset.value);
						const value = price * shares;
						priceCell.dataset.value = price;
						valueCell.dataset.value = value;
						const availableShares = Math.floor(balance / price);

						DOMupdates.push(() => {
							priceCell.style.color = "";
							priceCell.textContent = `$${price.toFixed(2)}`;

							valueCell.style.color = "";
							valueCell.textContent = `$${value.toFixed(2)}`;

							if (isFirstFetch) sellInput.disabled = false;

							buyInput.max = availableShares;
							if (availableShares > 0) {
								if (!transactionInProgress) buyInput.disabled = false;
								buyInput.min = 1;
							} else {
								if (!transactionInProgress) buyInput.disabled = true;
								buyInput.min = 0;
							}
						});

						updated++;
					} else {
						console.warn(`Invalid price received for holding: ${share.symbol}`);
						DOMupdates.push(() => {
							if (isFirstFetch) {
								priceCell.textContent = `$--`;
								valueCell.textContent = `$--`;
							}
							priceCell.style.color = "red";
							valueCell.style.color = "red";
							holding.querySelector(".sell-input").disabled = true;
							holding.querySelector(".buy-input").disabled = true;
						});
					}
				}
				const total = calculateTotal();
				DOMupdates.push(() => {
					totalCell.style.color = updated === holdings.length ? "" : "red";
					totalCell.textContent = isNaN(total) ? `$--` : `$${total.toFixed(2)}`;
					if (isFirstFetch) {
						sellButton.disabled = false;
						if (balance) buyButton.disabled = false;
					}
				});
			} catch (error) {
				console.error(error);
				DOMupdates.push(() => {
					totalCell.style.color = "red";
					buyButton.disabled = sellButton.disabled = true;
					holdings.forEach((holding) => {
						const priceCell = holding.querySelector(".price");
						const valueCell = holding.querySelector(".value");
						holding.querySelector(".sell-input").disabled = holding.querySelector(
							".buy-input"
						).disabled = true;
						priceCell.style.color = valueCell.style.color = "red";
						if (isFirstFetch) {
							priceCell.textContent = valueCell.textContent = totalCell.textContent = `$--`;
						}
					});
				});
			} finally {
				requestAnimationFrame(() => {
					for (const update of DOMupdates) {
						update();
					}})
			}
		};

		if (symbols.length) {
			table.style.display = "";
			updatePrices(true).then(() => {
				sellFormListener();
				buyFormListener();
				if (priceIntervalId) clearInterval(priceIntervalId);
				priceIntervalId = setInterval(() => {
					updatePrices()
						.then(() => {
							if (!transactionInProgress) {
								if (buyTotal.textContent) buyInputs[0].dispatchEvent(new Event("input"));
								if (sellTotal.textContent) sellInputs[0].dispatchEvent(new Event("input"));
							}
						})
						.catch((error) => console.error(error));
				}, interval);
			});
		} else {
			message.innerHTML =
				'No holdings to display - go to the <a href="/search">Search</a> page to start trading.';
		}

		const buyFormListener = () => {
			buyForm.addEventListener("submit", async (e) => {
				e.preventDefault();
				if (transactionInProgress) return;
				transactionInProgress = true;
				message.textContent = "";
				const purchases = [];
				let purchaseTotal = 0;
				let invalidInput = false;
				const holdings = document.querySelectorAll(".holding");
				for (const holding of holdings) {
					if (invalidInput) break;

					const buyInput = holding.querySelector(".buy-input");
					const currentShares = Number(holding.querySelector(".current-shares").dataset.value);
					const quantity = Number(buyInput.value);
					const symbol = holding.querySelector(".symbol").dataset.value;
					const price = Number(holding.querySelector(".price").dataset.value);

					purchaseTotal += quantity * price;
					if (quantity < 0 || !Number.isInteger(quantity) || !buyInput.checkValidity()) {
						invalidInput = true;
						break;
					}

					if (quantity > 0) {
						purchases.push({
							symbol: symbol,
							shares: quantity,
						});
					}
				}
				if (purchaseTotal > balance) {
					message.textContent = "Could not complete trade - insufficient funds.";
					transactionInProgress = false;
					return;
				}
				if (invalidInput) {
					message.textContent = "Invalid input - must be positive integers.";
					transactionInProgress = false;
					return;
				}
				if (!purchases.length) {
					message.textContent = "No shares selected to trade.";
					transactionInProgress = false;
					return;
				}

				const DOMupdates = [];

				try {
					buySpinner.style.setProperty("display", "flex", "important");
					buyButton.style.display = "none";
					document.querySelectorAll("input, button").forEach((el) => (el.disabled = true));
					const res = await fetch("/buy", {
						method: "POST",
						headers: {
							"Content-Type": "application/json",
						},
						body: JSON.stringify(purchases),
					});
					const data = await res.json();
					if (!res.ok) throw new Error(data?.error || `Error ${res.status}: ${res.statusText}`);
					if (!data || !data.updated_balance) throw new Error("Missing data");
					const updatedBalance = data.updated_balance;
					setBalance(updatedBalance);
					balance = updatedBalance;

					for (const holding of holdings) {
						const buyInput = holding.querySelector(".buy-input");
						const sellInput = holding.querySelector(".sell-input");
						const symbol = holding.querySelector(".symbol").dataset.value;
						const price = Number(holding.querySelector(".price").dataset.value);
						const sharesCell = holding.querySelector(".current-shares");
						const currentShares = Number(sharesCell.dataset.value);
						const valueCell = holding.querySelector(".value");
						const purchase = purchases.find((el) => el.symbol == symbol);
						const availableShares = price > 0 ? Math.floor(updatedBalance / price) : 0;

						DOMupdates.push(() => {
							buyInput.max = availableShares;
							buyInput.value = sellInput.value = "";
						});

						if (purchase) {
							const updatedShares = currentShares + purchase.shares;
							const updatedValue = price * updatedShares;

							DOMupdates.push(() => {
								sharesCell.dataset.value = updatedShares;
								valueCell.dataset.value = updatedValue;
								sellInput.max = updatedShares;
								sharesCell.textContent = updatedShares;
								valueCell.textContent = `$${updatedValue.toFixed(2)}`;
							});
						}
					}
					const total = calculateTotal();

					DOMupdates.push(() => {
						message.textContent = "Purchase Successful!";
						balanceCell.style.color = "";
						balanceCell.textContent = `$${updatedBalance.toFixed(2)}`;
						buyTotal.textContent = sellTotal.textContent = "";
						totalCell.dataset.value = total;
						totalCell.textContent = `$${total.toFixed(2)}`;
					});
				} catch (error) {
					console.error(error.message);
					message.textContent = error.message == "Insufficient funds" ? error.message : "Unexpected error";
				} finally {
					DOMupdates.push(() => {
						buySpinner.style.setProperty("display", "none", "important");
						buyButton.style.display = "";
						sellButton.disabled = buyButton.disabled = false;
						holdings.forEach((holding) => {
							const buyInput = holding.querySelector(".buy-input");
							const sellInput = holding.querySelector(".sell-input");
							if (Number(buyInput.max) > 0) {
								buyInput.disabled = false;
								buyInput.min = 1;
							} else {
								buyInput.disabled = true;
								buyInput.min = 0;
							}
							if (Number(sellInput.max) > 0) {
								sellInput.disabled = false;
								sellInput.min = 1;
							} else {
								sellInput.disabled = true;
								sellInput.min = 0;
							}
						});
					});
					requestAnimationFrame(() => {
						for (const update of DOMupdates) {
							update();
						}
					});
					transactionInProgress = false;
				}
			});
		};

		const sellFormListener = () => {
			sellForm.addEventListener("submit", async (e) => {
				e.preventDefault();
				if (transactionInProgress) return;
				transactionInProgress = true;
				const sales = [];
				const holdings = document.querySelectorAll(".holding");
				message.textContent = "";
				let invalidQuantity = false;
				let invalidInput = false;

				for (const holding of holdings) {
					if (invalidQuantity || invalidInput) break;

					const sellInput = holding.querySelector(".sell-input");
					const currentShares = Number(holding.querySelector(".current-shares").dataset.value);
					const quantity = Number(sellInput.value);
					const symbol = holding.querySelector(".symbol").dataset.value;

					if (quantity > currentShares) {
						invalidQuantity = true;
						break;
					}
					if (quantity < 0 || !Number.isInteger(quantity) || !sellInput.checkValidity()) {
						invalidInput = true;
						break;
					}

					if (quantity > 0) {
						sales.push({
							symbol: symbol,
							shares: quantity,
						});
					}
				}

				if (invalidQuantity) {
					message.textContent = "Could not complete trade - insufficient shares.";
					transactionInProgress = false;
					return;
				}
				if (invalidInput) {
					message.textContent = "Invalid input - must be positive integers.";
					transactionInProgress = false;
					return;
				}
				if (!sales.length) {
					message.textContent = "No shares selected to trade.";
					transactionInProgress = false;
					return;
				}

				const DOMupdates = [];

				try {
					sellSpinner.style.setProperty("display", "flex", "important");
					sellButton.style.display = "none";
					document.querySelectorAll("input, button").forEach((el) => (el.disabled = true));
					const res = await fetch("/sell", {
						method: "POST",
						headers: {
							"Content-Type": "application/json",
						},
						body: JSON.stringify(sales),
					});
					const data = await res.json();
					if (!res.ok) throw new Error(data?.error || `Error ${res.status}: ${res.statusText}`);
					if (!data || !data.updated_balance) throw new Error("Missing data");

					const updatedBalance = data.updated_balance;
					setBalance(updatedBalance);
					balance = updatedBalance;
					for (const holding of holdings) {
						const buyInput = holding.querySelector(".buy-input");
						const sellInput = holding.querySelector(".sell-input");
						const symbol = holding.querySelector(".symbol").dataset.value;
						const price = Number(holding.querySelector(".price").dataset.value);
						const sharesCell = holding.querySelector(".current-shares");
						const currentShares = Number(sharesCell.dataset.value);
						const valueCell = holding.querySelector(".value");
						const sale = sales.find((el) => el.symbol == symbol);
						const availableShares = price > 0 ? Math.floor(updatedBalance / price) : 0;

						DOMupdates.push(() => {
							buyInput.max = availableShares;
							sellInput.value = buyInput.value = "";
						});

						if (sale) {
							const updatedShares = currentShares - sale.shares;
							const updatedValue = price * updatedShares;
							DOMupdates.push(() => {
								valueCell.dataset.value = updatedValue;
								sharesCell.dataset.value = updatedShares;
								sharesCell.textContent = updatedShares;
								sellInput.max = updatedShares;
								valueCell.textContent = `$${updatedValue.toFixed(2)}`;
							});
						}
					}
					const total = calculateTotal();

					DOMupdates.push(() => {
						message.textContent = "Sale Successful!";
						balanceCell.style.color = "";
						balanceCell.textContent = `$${updatedBalance.toFixed(2)}`;
						buyTotal.textContent = sellTotal.textContent = "";
						totalCell.dataset.value = total;
						totalCell.textContent = `$${total.toFixed(2)}`;
					});
				} catch (error) {
					console.error(error.message);
					message.textContent = "Unexpected error";
				} finally {
					DOMupdates.push(() => {
						sellSpinner.style.setProperty("display", "none", "important");
						sellButton.style.display = "";
						buyButton.disabled = sellButton.disabled = false;
						holdings.forEach((holding) => {
							const buyInput = holding.querySelector(".buy-input");
							const sellInput = holding.querySelector(".sell-input");
							if (Number(buyInput.max) > 0) {
								buyInput.disabled = false;
								buyInput.min = 1;
							} else {
								buyInput.disabled = true;
								buyInput.min = 0;
							}
							if (Number(sellInput.max) > 0) {
								sellInput.disabled = false;
								sellInput.min = 1;
							} else {
								sellInput.disabled = true;
								sellInput.min = 0;
							}
						});
					});
					requestAnimationFrame(() => {
						for (const update of DOMupdates) {
							update();
						}
					});
					transactionInProgress = false;
				}
			});
		};

		buyInputs.forEach((input) => {
			input.addEventListener("input", (event) => {
				let buySum = 0;
				let countNaN = 0;
				buyInputs.forEach((input) => {
					const price = Number(input.closest("tr").querySelector(".price").dataset.value);
					const value = Number(input.value) || 0;
					if (isNaN(input.valueAsNumber)) countNaN += 1;
					buySum += price * value;
				});
				buyTotal.textContent = countNaN === buyInputs.length ? "" : `$${buySum.toFixed(2)}`;

				buyInputs.forEach((input) => {
					const price = Number(input.closest("tr").querySelector(".price").dataset.value);
					const value = Number(input.value) || 0;

					const remaining = balance - buySum + price * value;
					const availableShares = price > 0 ? Math.max(0, Math.floor(remaining / price)) : 0;
					input.max = availableShares;
					if (availableShares > 0) {
						input.min = 1;
					} else {
						input.min = 0;
					}
				});
			});
		});

		sellInputs.forEach((input) => {
			input.addEventListener("input", (event) => {
				let sellSum = 0;
				let countNaN = 0;
				sellInputs.forEach((input) => {
					const price = Number(input.closest("tr").querySelector(".price").dataset.value);
					const value = Number(input.value) || 0;
					if (isNaN(input.valueAsNumber)) countNaN += 1;
					sellSum += price * value;
				});
				sellTotal.textContent = countNaN === sellInputs.length ? "" : `$${sellSum.toFixed(2)}`;
			});
		});
	});
</script>

{% endblock %}
